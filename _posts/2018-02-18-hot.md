---
layout:     post
title:      "热数据"
date:       2018 Feb 18
categories: math
tags:       architecture data consistence
---

# 引言

## 淘宝

- 公元前300年: 欧几里得写了一本书:《几何原本》包含与素数有关的重要定理，如有无限多个素数

  这也许是有记载的人类第一次认识质数, 当时的人们并不知道这东西有什么卵用, 只是觉得好玩研究一下.
  
  在我看来人类发展依靠2种智力能力, 好奇心和想象力(记忆力和推理能力更基础, 但还不是核心的驱动力.), 前者驱使人类探索未知的世界, 后者将探索到的规律拿来, 找到需要的场景, 改变这个世界.
  
  欧几里得研究质数的时候, 还不知道他们的好奇心将对未来的人类产生多大的影响.

- : 中国余数定理

- 1640年: 费马小定理 $ a^{p-1} = 1 mod p $

  费马小定理在之后许多数学定理里都能看到它的形式.
  但费马在当年, 也还不知道这个东西有什么卵用.

- 1736年: 欧拉函数 $ a^{\varphi(n)} = 1 mod n $ , $ \varphi(n) $ 是和n互质的数字个数.

  欧拉函数是费马小定理的推广形式, 它描述了自然数更通用的性质(不再像费马小定理一样只对质数p有效).
  
  欧拉函数的证明用到了上面的 中国余数定理.

  遗憾的是当年欧拉也不知道他的函数有啥卵用.

- 1977年: RSA
https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95

  罗纳德·李维斯特, 阿迪·萨莫尔, 和伦纳德·阿德曼一起提出的

  卵用来了. RSA, 加密通讯的基础算法,基于对大数质因数分解的超大运算量, 制造解密的壁垒.
  只有通讯双方知道原始秘钥, 才能进行正确的加密解密, 中间人几乎无法通过计算的方法来读取到通讯信息.

- 1995年: SSL 塔希尔·盖莫尔

  基于RSA算法的计算代码实现, 基于SSL的库, 互联网上的安全通讯成为了现实.

- 2003年: 淘宝

  最终的卵用就是, 互联网上的钱的交易可以安全的完成, 让亲们可以放心的剁手.
  
  亲们清空购物车的时候, 要记得感谢欧几里得, 费马, 欧拉, 


## CD


- 1832年: 群论 埃瓦里斯特·伽罗瓦 

  群论在抽象代数里作为一个重要的分支, 其中很多特性都与质数相关, 包括有限域(finite field)的元素个数只能是质数的n次幂等. (其实质数的特性在数学中各种分支都有它的影子, 群论并不是最特殊的一个).
  
  如果加减乘除的四则运算将数字联系起来, 群论可以认为是将其他非数字的结构也赋予了运算的能力, 它允许使用类似四则运算的方式研究其他规律. (例如魔方的旋转状态, 正多边形顶点着色问题)
  
  就像懂得了四则运算之后, 人们对数字的理解和控制大大加强, 通过群论的理论, 之前很多看似困难的问题也迎刃而解:

  - 他系統化地闡釋了為何五次以上之方程式没有根式解，而四次以下有根式解。
  - 他漂亮地證明高斯的論斷：若用尺規作圖能作出正p邊形，p為質數 $ p=2^{2^{k}}+1 $和$ p=2^{2^{k}}+1 $ 等价（所以正十七邊形可做圖）。
  - 他解決了古代三大作圖問題中的兩個：「不能任意三等分角」，「倍立方不可能」。


- 1960年: Reed–Solomon: Irving S. Reed and Gustave Solomon

  RS使用基于 伽罗瓦的有限域的理论, 构造了1个允许少量数据丢失还能还原全量数据的算法.
  
  > 基于 伽罗瓦 的理论, RS 使用一个 $ 2^8 $ 大小的有限域来表示一个字节的256个值.
  > 对 RS 有兴趣的同学可以参考我们另外一篇文章 xxx, 里面对RS的原理从下到上给出了详尽简单的解释.

  RS在数据冗余方面作用巨大,不论是传输层还是存储层,
  
  但是, 这时RS还没有直接影响到我们的日常生活. 直到...

- 1993年: VCD 出现.

  VCD 在当时流行的程度填满了普通人的日常生活, 这种大容量稳定的存储介质让很多影视作品广泛流传.
  在在线视频还没有流行起来的时候, VCD无疑是休闲娱乐的代名词.
  
  但并不是很多人知道, 这种被人借来借去后, 表面布满划痕后还能正常播放的廉价存储介质, 用的就是Reed Solomon编码, 来保证VCD上一个小区域上, 部分信息损坏还可以将影片读取出来.
  
  > 但是这种冗余也有个上限, 当信息实在损坏严重的时候, 屏幕上就会出现马赛克和发出丝丝的声音.
  
  看片的时候, 要记得, 被gay密划伤的碟还能放出月光宝盒, 都是 伽罗瓦, Reed, Solomon的功能.


- 现在: Bar code



# 两大问题

> There are only two hard things in Computer Science: cache invalidation and naming things.
> 
> -- Phil Karlton

最初读到这句话时的感觉很有同感. 虽然没有正式的文档记载这句话(一位栈溢出的朋友声明他在采访Karlton时他确实说过). 不论是否是他真的说过这么一句话, 还是没有, 都并不重要, 比起一个名人的出处, 我更在意这句话本身的意义(顺便发个牢骚, 那么多惊世警句, 如果真的是正确的话, 不需要每句都由马云来说).

可惜的是 Karlton 在1997 出车祸身亡. 如果老先生还在, 以在那个年代就能对计算机科学有这么深刻的认识, 如今可能会给世人带来更多的启发.

说起这2个问题, 一个是命名, 一个是缓存清除, Karlton没有做过多的解释, 在我的理解中, 这2个问题在不同场景有不同的解释.

# 命名

命名的问题可以认为是对信息的组织, 尤其是对要处理大量信息的学科. 像化学分子的命名规则, 生物分类的命名, 这两个场景里, 命名都在解决类似的问题:

- 将大量对象给出一个名字(而不是直接描述分子式或生物个体的全部特征来标识一个分子或动物)
- 要求能很好的抽象出对象的关键特征(而不是全部特征), 如氢氧化钠(NaOH), 标识出了准确的成分构成,用"化"字简单的标识出了结构关系.
- 要尽量简短. 我从来没能记得成功记得一个动物的拉丁文生物学名字, 他们的名字比起正常的单词要复杂很多, 但对于描述这个动物的特征或他在动物分类里的关系和位置来说, 已经太简单了.

计算机科学也面临同样的问题, 而软件设计上要进行命名的对象可能更多.

- 最小的集合可能一个网站所有的url的设计, 不少文章总结了作者自己的经验给出了很不错规范.
- 稍大一点的是源代码中上万个变量/函数的命名:
  > ‘Programs are meant to be read by humans and only incidentally for computers to execute.’
  > 
  > - Donald Knuth
  源代码的目的是为了让人与人之间流程的交换思想(就像文学作品一样), 快速准确地把信息传达给读者是首要目标, 而一个函数的好的名字可以帮助作者达到这一目的.
  
  命名的重要性的一个例子, 如果没有命名, 会这样:
  
  > 我: 我想给大约200万个数字排序, 应该怎么做?
  > 我的同事: 用`先找个pivot数字,然后通过顺序遍历每个数字与之和pivot比较交换到数组两端, 最终把数组拆分成小于pivot和大于pivot的2组数组再分别对2个数组进行同样的操作最终所有的数字就排好序了的算法`.
  > 我: 哦, 好. 这个`先找个pivot数字,然后通过顺序遍历每个数字与之和pivot比较交换到数组两端, 最终把数组拆分成小于pivot和大于pivot的2组数组再分别对2个数组进行同样的操作最终所有的数字就排好序了的算法`的时间效率大概是多少?.
  > 我的同事: 大约是`和输入数组大小和输入数组大小的对数,以及一个实现相关的常量成正比`的时间效率.
  > 我: 哦, 好.
  
  正常的对话是:

  > 我: 我想给大约200万个数组排序, 应该怎么做?
  > 我的同事: 快速排序.
  > 我: 哦, 好. 这个快速排序的时间效率大概是多少?
  > 我的同事: 大约是`O(n log(n))`的效率.
  > 我: 哦, 好.
  
  15% designing the behaviour
20% writing the tests
10% implementation
5% writing the documentation (just XML docs)
50% figuring out the best name

## 数据管理数据的命名

对于问题的描述和解答, 命名实在太重要了. 人类的阅读速度很有限, 阅读时接受信息的误差也很大, 正确准确的没有误导的名字对于信息交流可以提升几十倍的效率.

对于让机器管理的数据, 也会面临同样的问题.

机器虽然不太需要理解, 但也需要管理和消费.

### 对时间的命名
计算机发展过程中一个失败的命名就是对时间的命名, 也就是对每一秒给出一个确定的数字与之对应.

这事在2000年左右被发现之前的时间格式太短了,表示不了2000年以后的时间, 导致人心惶惶的千年虫事件.
虽然这事被很顺利的解决, 但应该是最著名的一次命名的失误了.


### ipv4 到 ipv6

ipv4 是另外一个命名空间不足的例子, 这个例子不像千年虫那样出名, 非计算机从业者也不太容易感知到它的影响.

简单说, 就是网络地址最初的设计不够用了, 为了解决网络地址不够用的问题, 地址转换的各种解决方案和对应的设备到处产生.

## 机器命名的问题

总的说来, 千年虫和ipv4的问题是同一个问题, 命名问题, 也是在计算机领域最经常要解决的一个问题:

**如何用较少的文字高效地表示更多的信息**.

这里的高效指运算简单(如果有运算的话), 并且非关键的信息更少.

在程序设计中, 命名问题体现在如何选择一个准确精炼的函数名, 例如 快速排序算法之于它的具体实现.
在数据管理上, 命名问题体现为为各种资源的命名. 如千年虫是关于对每个时间点命名的.

10进制数字就是一个很好的命名的例子, 它将所有的整数用10个符号的排列组合来表示, 简化了表达, 简化了理解, 也简化了操作.

在更基础的层面, 一个命名问题最典型的体现就是 hash table.

### Hash table

hash table是跟很有趣的数据结构, 它试图用有限个名字表示无限多个对象.

- 如sha1 将所有可能的字符串映射到 `2^160` 个20字节长的符号上. 因为我们在使用时, 没有机会枚举所有源字符串的组合, 也就是说, 在实际中, 我们是将一个大集合中的部分元素, 通过sha1这个算法, 映射到一个小集合里(`2^160`个元素), 因为实际用到的源字符串并不是很多, 映射到小集合之后的冲突几率也非常小. 所以我们可以认为, 通过sha1算法,我们对所有字符串都赋予了一个名字, 每个名字的长度都是 20 字节. 因为冲突率非常小, 我们可以认为, 我们给有限多个任意长度的字符串赋予了一个足够短,短到容易操作的名字. 

而实际中我们也是这样操作的, 例如很长一段时间以来, 在很多个存储系统的实现中, 都使用sha1作为文件的唯一id, 可以是一部电影, 或一个电话号码, 都可以统一的用一个20字节的`名字`来表示. 

当我们需要知道1个文件是否已经存在于存储系统中的时候, 我们就可以这样做:
对每个文件计算它的sha1, 记录在数据库中, 然后再计算一下目标文件的sha1, 对比数据库中记录的所有文件的sha1来确定这个文件是否存在.
而不需要对目标文件的每个字节对比存储系统中的每个文件的每个字节.
一次对比的存在与否的时间开销,降低了不知道多少个数量级.

这就是命名的意义. 用关键信息来命名, 来降低某些特定操作的复杂度.

### hash的优劣

sha1在之前一段时间, 可以说是很好的**任意内容**的命名方式:

它长度不长, 冲突率也很低.

相比另外一种摘要算法crc32, 它就不适合作为文件的唯一id: 它只有`2^32`个值, 虽然更短, 但也更容易产生冲突: 两个文件计算出的crc32值一样. 这样就不适合做命名的唯一id.

关于hash table, 参考 link...
它介绍了hash table中冲突的各种特性.

### hash的挑战.

hash算法(如sha1)的设计, 可能是计算机领域最优挑战的事情了, 因为它要做的是对无限多个可能出现的东西命名, 要设计一种应对未知情况的算法.







# 缓存

缓存的踢出, 和hash其实非常类似.

hash要解决的是将较多的东西用较少的东西来命名, 缓存踢出要解决的问题是对未来可能被使用到的东西做决定:留下来还是暂时删除掉.

缓存踢出和命名实际上是一个问题: 给判定为要被访问到的东西一个类名字, 给判定为不会被访问到的东西另一类名字. 不同的是, 如何命名.

# 一致性

命名是在空间上的问题: 如何管理现在已经存在东西.
一致性是时间上的问题: 如何确定事件出现的先后.

分布式领域中, 时序问题是唯一的问题.
因为数据的变化每时每刻发生在多个地方, 同一条数据的多地多次修改最终如何统一成最终的结果, 这是分布式系统中核心的问题. 这个问题困难的地方在于, 如何确定数据变化的事件发生的时间顺序.



# dynamo

# paxos

# generalized paxos


hot data

identify a record
consistency

compacted index

global unique id





